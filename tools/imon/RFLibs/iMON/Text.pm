package RFLibs::iMON::Text;
$RFLibs::iMON::Text::VERSION = '1.00';

################################################################################
#
#	Created by Ronald Frazier
#	http://www.ronfrazier.net
#
#	Feel free to do anything you want with this, as long as you
#	include the above attribution.
#
################################################################################


use strict;
use threads;
use threads::shared;
use Thread::Semaphore;
use Time::HiRes qw(usleep);

use RFLibs::iMON 1.00;
use RFLibs::iMON::Utils 1.00;
use RFLibs::Threads 1.00;
use RFLibs::ProportionalText 1.00;

@RFLibs::iMON::Text::ISA = qw(Exporter);
@RFLibs::iMON::Text::EXPORT = qw(

			setupImonText
			cleanupImonText

			createTextArea
			setAreaText

			createScreen
			setScreenMultiLineText

			showScreen
			getScreenCycleStatus
                      );


my %screens : shared;
my %areas : shared;
my $activeScreen : shared = '';
my %fonts : shared;

my $fontpath;

my $RunTextScrolling = new Thread::Semaphore(0);

sub setupImonText
{
   ($fontpath) = @_;
	thread_start('textscroll', \&threadbody_scrollText);
};


sub cleanupImonText
{
	thread_stop('textscroll', 1);
	$RunTextScrolling->up;
};


sub createTextArea
{
	my ($name, $font, $scrolltype, $repeattype, $align) = @_;

	die "Invalid area scroll type '$scrolltype'" unless $scrolltype =~ /^(none|smooth|character|(quarter|half)?page)$/;
	die "Invalid area repeat type '$repeattype'" unless $repeattype =~ /^(none|loop|repeat|reverse)$/;
	
	my %area : shared;
	$area{class} = 'area';
	$area{type} = 'text';
	$area{name} = $name;
	$area{font} = $font;
	$area{scrolltype} = $scrolltype;
	$area{repeattype} = $repeattype;
	$area{align} = $align;
	
	loadFont($font);
	$area{height} = $fonts{$font}->{bits};

	resetTextScroll(\%area);
	
	
	$areas{$name} = \%area;
};

sub setAreaText
{
	my ($areaname, $text, $keep_scroll_state) = @_;
	
	my $area = $areas{$areaname};
	die "'$areaname' is not a textarea" unless $area->{type} eq 'text';
	return if ($area->{text} eq $text);
	
	$area->{text} = $text;
	($area->{bitmap}, $area->{width}) = rasterizeTextBitmap($text, $area->{font});

	my (@pieces, @widths);
	my $charwidths = $fonts{$area->{font}}->{widths};
	RFLibs::ProportionalText::splitWords($text, $charwidths, \@pieces, \@widths);

	#generate the list of scrollstops	
	my @possible_scrollstops;
	my $total_width = 0;
	while(scalar(@pieces))
	{
		my $piece = shift @pieces;
		my $width = shift @widths;

		push(@possible_scrollstops, $total_width) unless $piece =~ /^\s*$/;

		$total_width += $width;
	};
	unshift(@possible_scrollstops, 0) unless ($possible_scrollstops[0] == 0);
	my @scrollstops = generateScrollStopList($total_width, 96, 24, @possible_scrollstops);
	
	
	$area->{modified} = 1;
	$area->{scrollstops} = join(',', @scrollstops);

	resetTextScroll($area) unless $keep_scroll_state;
};


sub createScreen
{
	my ($name, $scrolltype, $repeattype, @areas) = @_;

	die "Invalid screen scroll type '$scrolltype'" unless $scrolltype =~ /^(none|smooth)$/;
	die "Invalid screen repeat type '$repeattype'" unless $repeattype =~ /^(none|loop|repeat|reverse)$/;
	
	my %screen : shared;
	$screen{class} = 'screen';
	$screen{name} = $name;
	$screen{scrolltype} = $scrolltype;
	$screen{repeattype} = $repeattype;

	initScreenProperties(\%screen, \@areas);
	
	$screens{$name} = \%screen;
};

sub setScreenMultiLineText
{
	my ($screenname, $text, $fontname, $align) = @_;
	
	my $screen = $screens{$screenname};

	#delete the old areas if they were autogenerated	
	foreach my $ctr (1..$screen->{areacount})
	{
		my $areaname = $screen->{'area', $ctr};
		delete $areas{$areaname} if ($areaname eq "$screenname$;$ctr");
		delete $screen->{'area', $ctr};
	};
	
	loadFont($fontname);
	my $charwidths = $fonts{$fontname}->{widths};

	my @lines = wrapText($text, $charwidths, 96, 48, 3);

	#autogenerate new areas
	my $ctr = 0;
	my @areanames;
	foreach my $line (@lines)
	{
		$ctr++;
		my $areaname = "$screenname$;$ctr";
		createTextArea($areaname, $fontname, 'none', 'none', $align);
		setAreaText($areaname, $line);
		push @areanames, $areaname;
	};

	initScreenProperties($screen, \@areanames);
	resetTextScroll($screen);
};



sub showScreen
{
	my ($screenname) = @_;
	
	return if $screenname eq $activeScreen;
	
	if ($screenname eq '')
	{
		$activeScreen = '';
		return;
	};
	
	die "Invalid screen '$screenname' " unless exists $screens{$screenname};

	#build a list of current areas
	my %old_areas;
	my $oldscreen = $screens{$activeScreen};
	foreach my $ctr (1..$oldscreen->{areacount})
	{
		$old_areas{$oldscreen->{'area',$ctr}}++;
	}

	my $was_blank = ($activeScreen eq '');

	$activeScreen = $screenname;
	my $screen = $screens{$screenname};
	
	#reset only those areas that weren't part of the last screen (don't interrupt their scrolling)
	foreach my $ctr (1..$screen->{areacount})
	{
		my $areaname = $screen->{'area',$ctr};
		next if $old_areas{$areaname};

		my $area = $areas{$areaname};
		resetTextScroll($area);
	}

	resetTextScroll($screen);
	$RunTextScrolling->up if $was_blank;
};


sub getScreenCycleStatus
{
	my ($screenname) = @_;

	my $screen = $screens{$screenname};
	return -1 unless $screen;

	return $screen->{cycle_complete};
};







sub initScreenProperties
{
	my ($screen, $areanames) = @_;
	
	my $ctr = 0;
	my $height = 0;

	my @possible_scrollstops;
	foreach my $areaname (@$areanames)
	{
		die "Unknown area '$areaname'" if !exists($areas{$areaname});

		push (@possible_scrollstops, $height);
		$screen->{'area', ++$ctr} = $areaname;
		$height += $areas{$areaname}->{height};
	};
	my @scrollstops = generateScrollStopList($height, 16, 1, @possible_scrollstops);

	$screen->{areacount} = $ctr;
	$screen->{height} = $height;
	$screen->{scrollstops} = join(',', @scrollstops);
};

sub generateScrollStopList
{
	my ($totalsize, $display_size, $closest_to_end, @possible_scrollstops) = @_;
	
	#if it's small enough that we have no need for scroll stops, return the first one
	return shift(@possible_scrollstops) if $totalsize <= $display_size;

#	print join(',',@possible_scrollstops, $totalsize), " => ";
	
	#chop off any that are too close to the end
	my $last_possible = $totalsize - $closest_to_end;
	pop(@possible_scrollstops) while (@possible_scrollstops[$#possible_scrollstops]  > $last_possible);	

	push(@possible_scrollstops, $totalsize);
	my @scrollstops;
	
	
	my $last_added = -$display_size;
	my $last_stop = shift @possible_scrollstops;
	while(my $stop = shift @possible_scrollstops)
	{
		if (($stop-$last_added) > $display_size)
		{
			push(@scrollstops, $last_stop);
			$last_added = $last_stop;
		};
		$last_stop = $stop;
	};
	
#	print join(',',@scrollstops), "\n";
	
	return @scrollstops;
};

sub resetTextScroll
{
	foreach my $item (@_)
	{
		$item->{scroll_offset} = 0;
		$item->{modified} = 1;

		$item->{scrollstate} = 'startwait';
		$item->{scrollstate_entered} = Time::HiRes::time();
		$item->{scroll_direction} = 1;
		$item->{cycle_complete} = 0;

		$item->{next_scrollstop} = 0 if exists $item->{scrollstops};
	};
};

sub loadFont
{
	my ($fontname) = @_;
	
	return if $fonts{$fontname};
	
	my %chars : shared;
	my %widths : shared;

	my @lines = `cat $fontpath/$fontname.font`;
	foreach my $line (@lines)
	{
		$line =~ s/[\r\f\n]+$//;
		next unless $line =~ /^(.)=(\d+):([0-9a-fA-F ]+)/;
		my $char = $1;
		my $bits = $2;
		my @cols = split(' ', $3);

		my $data;
		foreach my $col (@cols)
		{
			$data .= pack("S", hex($col));
		};

		$chars{$char} = $data;
		$widths{$char} = scalar(@cols);
		$chars{'bits'} = $bits if ($bits > $chars{'bits'});
	};
	$chars{'widths'} = \%widths;
	$fonts{$fontname} = \%chars;
};

sub rasterizeTextBitmap
{
	my ($text, $fontname) = @_;

	my $font = $fonts{$fontname};

	my $data;
	foreach my $char(split //,$text)
	{
		$data .= $font->{$char};
	};
	return ($data, length($data)/2);
}


#take a list of areas and a starting y coordinate, and render them to a bitmap
sub generateBitmapBinary
{
	my ($y, @arealist) = @_;

	#go through each bitmap
	my $bitmap = pack("S", 0) x 96;

	my $bits;	
	foreach my $area (@arealist)
	{
		$bits = $area->{height};

		#determine if the area will even be visible
		next if (($y+$bits) <= 0);
		last if ($y >= 16);
		
		#determine how it the area will be aligned/scrolled horizontally
		my $x = -$area->{scroll_offset};
		my $w = $area->{width};
		if ($w < 96)
		{	
			$x = ($area->{align} eq 'left') ? 0 :
				($area->{align} eq 'center') ? int((96-$w)/2) :
				($area->{align} eq 'right') ? 96-$w :
				0;
		};

		#draw the area
		$bitmap = drawIntoBitmap($area->{bitmap}, $bitmap, $x, $y, $bits);
	}
	continue
	{
		$y += $bits;
	};

	return $bitmap;
};

sub bitmapBinaryToImon
{
	my ($bitmap) = @_;

	my @bitmap_array = unpack("S96", $bitmap);

	#convert bitmap into a forum suitable for the iMON library (1 byte half-columns ... left to right ... top half then bottom half)
	my ($top, $bottom);
	foreach my $i (0..95)
	{
		my $col = $bitmap_array[$i];
		$top .= sprintf("%02x", ($col >> 8) & 0x00ff);
		$bottom .= sprintf("%02x",  $col & 0x00ff);
	};
	
	return $top.$bottom;
};

sub generateBitmap
{
	my $bitmap = generateBitmapBinary(@_);
	return bitmapBinaryToImon($bitmap);
};


sub getScrollAttr
{
	my ($item, $name) = @_;
	my ($class, $scroll, $repeat) = @{$item}{'class', 'scrolltype', 'repeattype'};

	return 2 if ($name eq 'initial_delay');
	
	if ($name eq 'scroll_delay')
	{
		return 0.2 	if ($class  eq 'screen');
		return 0.15 	if ($scroll eq 'smooth');
		return 0.4 	if ($scroll eq 'character');
		return 1.0 	if ($scroll eq 'quarterpage');
		return 1.5 	if ($scroll eq 'halfpage');
		return 3.0 	if ($scroll eq 'page');
		die "Can't determine scroll_delay for $class + $scroll";
	};

	if ($name eq 'scroll_increment')
	{
		return 2 	if ($class  eq 'screen');
		return 3 	if ($scroll eq 'smooth');
		return 10 	if ($scroll eq 'character');
		return 24 	if ($scroll eq 'quarterpage');
		return 48 	if ($scroll eq 'halfpage');
		return 96 	if ($scroll eq 'page');
		die "Can't determine scroll_increment for $class + $scroll";
	};

	if ($name eq 'scroll_pause')
	{
		return 2 	if ($class eq 'screen');
		return 2 	if (($scroll eq 'smooth') || ($scroll eq 'character'));
		return 0;
	};

	if ($name eq 'repeat_wait')
	{
		return 0 	if ($repeat eq 'loop') && (($scroll eq 'quarterpage') || ($scroll eq 'halfpage') || ($scroll eq 'page'));
		return 0 	if ($repeat eq 'loop');
		return 2;
	};

	die "Unknown scroll attribute of $name requested";
};

sub threadbody_scrollText
{
	my $redraw = 1;
	my $was_blank;
	while(1)
	{
		$RunTextScrolling->down;

		last unless thread_running();

		$was_blank = $activeScreen eq '';
		if ($was_blank)
		{
			setBitmap();
			next;
		};

		my $screen = $screens{$activeScreen};
		next unless $screen;


		my $now = Time::HiRes::time();

		$redraw |= scrollText_handleScreen($screen, $now);

		next unless $redraw;


		my ($top, @arealist) = scrollText_getAreasInRange($screen, $screen->{scroll_offset}, 1, 1, 0);
		
		my $bitmap = generateBitmap($top, @arealist);

		setBitmap($bitmap);
		
	}
	continue
	{
		usleep(100000);
		$redraw = 0;
		$RunTextScrolling->up unless $was_blank;
	};
};


sub getAreasByName
{
	my @areas;
	foreach my $name (@_)
	{
		push @areas, $areas{$name};
	};
	
	return @areas;
};

sub scrollText_getAreasInRange
{
	my ($screen, $min_y, $include_partially_above, $include_partially_below, $swap_if_reverse) = @_;

	if ($swap_if_reverse && ($screen->{scroll_direction} == -1))
	{
		($include_partially_above, $include_partially_below) = ($include_partially_below, $include_partially_above);
	};


	my $max_y = $min_y+15;
	my $top = 0;
	my $bottom;
	
	my $first_y = -999999;
	my @areas;
	foreach my $ctr (1..$screen->{areacount})
	{
		my $area = $areas{$screen->{'area',$ctr}};
		
		$bottom = $top + $area->{height} - 1;
		
		if ($include_partially_above)
		{
			next if ($bottom < $min_y);
		}
		else
		{
			next if ($top < $min_y);
		};
		
		if ($include_partially_below)
		{
			next if ($top > $max_y);
		}
		else
		{
			next if ($bottom > $max_y);
		};
		
		
		$first_y = $top if $first_y == -999999;
		push(@areas, $area);
	}
	continue
	{
		$top = $bottom+1;
	};

	return ($first_y-$min_y, @areas);
};

sub scrollText_selectNextScrollStop
{
	my ($item) = @_;

	my @stops = split(',', $item->{scrollstops});
	@stops = reverse(@stops) if ($item->{scroll_direction} == -1);

	while (scalar(@stops))
	{
		my $stop = shift(@stops);
		last if ($stop == $item->{next_scrollstop});
	};

	return 0 unless scalar(@stops);

	$item->{next_scrollstop} = $stops[0];

	if ($item->{class} eq	 'screen')
	{
		#now reset all of text areas that will be visible at the next scrollstop
		my (undef, @areas) = scrollText_getAreasInRange($item, $item->{next_scrollstop}, 0, 1, 1);
		resetTextScroll(@areas);
	};
	
	return 1;
};

sub scrollText_sleepNeeded
{
	my ($item, $wait_time, $now) = @_;
	
	my $wait_until = $item->{scrollstate_entered} + $wait_time;
	return 0 if ($now >= $wait_until);
	
	$item->{sleepuntil} = $wait_until;
	return 1;
};

sub scrollText_handleItems
{
	my ($items, $now) = @_;
	
	my $redraw = 0;

	foreach my $item (@$items)
	{
		scrollText_selectNextScrollStop($item) if($item->{scroll_offset} == $item->{next_scrollstop});

		my $item_type = $item->{class};
		my $display_size = ($item_type eq 'area') ? 96 : 16;
		my $item_size = ($item_type eq 'area') ? $item->{width} : $item->{height};
		
		if ($item->{modified})
		{
			$item->{modified} = 0;
			$redraw = 1;
		};

		next if $now < $item->{sleepuntil};
		next if ($item->{scrollstate} eq 'finished');

		if ($item->{scrollstate} eq 'startwait')
		{
			my $done = scrollText_startwait($item, $item_size, $display_size, $now);
			next if $done;
		};

		if ($item->{scrollstate} eq 'scrolling')
		{
			my ($done, $ret_redraw) = scrollText_scrolling($item, $item_size, $now);
			$redraw ||= $ret_redraw;
			next if $done;
		}

		if ($item->{scrollstate} eq 'repeatwait')
		{
			my ($done, $ret_redraw) = scrollText_repeatwait($item, $item_size, $display_size, $now);
			$redraw ||= $ret_redraw;
			next if $done;
		};
	}
	
	return $redraw;
};


sub scrollText_handleScreen
{
	my ($screen, $now) = @_;

	my $redraw = 0;

	my (undef, @areas) = scrollText_getAreasInRange($screen, $screen->{scroll_offset}, 1, 1, 0);
	foreach my $area (@areas)
	{
		next unless $area->{modified};
		$area->{modified} = 0;
		$redraw = 1;
	};

	if ($screen->{scrollstate} eq 'finished')
	{
		$redraw |= scrollText_handleItems(\@areas, $now);
		return $redraw
	};
	
	my $at_stop_before = $screen->{scroll_offset} == $screen->{next_scrollstop};

	#if we are at one of our scroll stop points, dont continue scrolling until all visible scroll areas 
	#have had a chance to run their cycle, then proceed scrolling until the next stop.
	if ($at_stop_before)
	{

		my (undef, @areas) = scrollText_getAreasInRange($screen, $screen->{scroll_offset}, 0, 0, 0);
		$redraw |= scrollText_handleItems(\@areas, $now);

		foreach my $area (@areas)
		{
			return $redraw if !$area->{cycle_complete};
		};
	};
	

	my $screen_height = $screen->{height};

	return $redraw if ($screen->{scrollstate} eq 'finished');


	$redraw |= scrollText_handleItems([$screen], $now);

	my $at_stop_after = $screen->{scroll_offset} == $screen->{next_scrollstop};

	#if we weren't at a scroll stop before, but now we are, then reset the text areas again.
	#The last time we did it, it was to reset their appearance. this time is to reset their timer
	if (!$at_stop_before && $at_stop_after)
	{
		my (undef, @areas) = scrollText_getAreasInRange($screen, $screen->{next_scrollstop}, 0, 1, 1);	
		resetTextScroll(@areas);
	};
		
	return $redraw;
};


sub scrollText_startwait
{
	my ($item, $item_size, $display_size, $now) = @_;
	
	my $initial_delay = getScrollAttr($item, 'initial_delay');
	return 1 if scrollText_sleepNeeded($item, $initial_delay, $now);

	if (($item->{scrolltype} eq 'none') || ($item_size < $display_size))
	{
		$item->{scrollstate} = 'finished';
		$item->{scrollstate_entered} = $now;
		$item->{cycle_complete} = 1;
		return 1;
	};
				
	$item->{scrollstate} = 'scrolling';
	return 0;
};


sub scrollText_scrolling
{
	my ($item, $item_size, $now) = @_;


	my $scroll_delay = getScrollAttr($item, 'scroll_delay');
	my $scroll_increment = getScrollAttr($item, 'scroll_increment');
	my $scroll_pause = getScrollAttr($item, 'scroll_pause');
	
	if ($scroll_pause > 0)
	{
		my $distance_to_stop = abs($item->{next_scrollstop} - $item->{scroll_offset});
		$scroll_increment = $distance_to_stop if ($scroll_increment > $distance_to_stop);
	};
	$scroll_increment *= $item->{scroll_direction};

	return (1,0) if scrollText_sleepNeeded($item, $scroll_delay, $now);
				
	my $pos = $item->{scroll_offset} + $scroll_increment;

	my $redraw = 0;				
	if (($pos == $item->{scroll_offset}) || (($scroll_pause == 0) && ($pos > $item_size)))
	{
		$item->{scrollstate} = 'repeatwait';
		$item->{scrollstate_entered} = $now;
	}
	else
	{
		$item->{scroll_offset} = $pos;
		$item->{scrollstate_entered} = $now;
		$redraw = 1;

		if (($item->{scroll_offset} == $item->{next_scrollstop}) && ($item->{next_scrollstop} <= $item_size))
		{
			$item->{sleepuntil} = $now + $scroll_pause; 
		};
	};	
	
	return (0, $redraw);		
};

sub scrollText_repeatwait
{
	my ($item, $item_size, $display_size, $now) = @_;
	

	my $repeat_wait = getScrollAttr($item, 'repeat_wait');

	return (1,0) if scrollText_sleepNeeded($item, $repeat_wait, $now);
	
	my $redraw = 0;
	$item->{cycle_complete} = 1;
	if ($item->{repeattype} eq 'repeat')
	{
		$item->{scroll_offset} = 0;
		$item->{scrollstate} = 'startwait';
		$item->{scrollstate_entered} = $now;
		$item->{next_scrollstop} = 0;
		$redraw = 1;
	}
	elsif ($item->{repeattype} eq 'reverse')
	{
		$item->{scroll_direction} *= -1;
		$item->{scrollstate} = 'scrolling';
		scrollText_selectNextScrollStop($item);
	}
	elsif ($item->{repeattype} eq 'loop')
	{
		#the first time this gets executed, it make a fake scrollstop way past the end
		if (($item->{scrollstops} =~ /(\d+)$/) && ($1 == $item->{next_scrollstop}))
		{
			$item->{next_scrollstop} = $item_size + int($display_size /4);
		}
		#the next time it gets called, it jumps to the left of the first scrollstop
		else
		{
			$item->{scroll_offset} = -$display_size;
			$item->{next_scrollstop} = 0;
			$redraw = 1;
		}
		$item->{scrollstate} = 'scrolling';
	}
	else
	{
		$item->{scrollstate} = 'finished';
		$item->{scrollstate_entered} = $now;
		$item->{next_scrollstop} = 0;
	};

	return(1, $redraw);
};

return 1;
